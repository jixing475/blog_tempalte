[
  {
    "path": "posts/2020-12-20-using-the-tidyverse-with-dbs-partii/",
    "title": "Using the tidyverse with Databases - Part II",
    "description": "I was serious, you don't need to be a SQL expert to work with Databases through R",
    "author": [
      {
        "name": "Vebash Naidoo",
        "url": "https://twitter.com/Sciencificity"
      }
    ],
    "date": "2020-12-20",
    "categories": [
      "SQL",
      "databases",
      "tidyverse",
      "dbplyr"
    ],
    "contents": "\r\n\r\nContents\r\nPart I\r\nWhat are we tackling in Part II?\r\nConnect, and remind ourselves what we’re working withMake a connection\r\nLet’s get familiar with our dataresults\r\nbaker_results\r\n\r\n\r\nWhat are we interested in?Joining dataRemember the tbl(con, \"tbl_name\") always\r\n\r\nCollectWhat does the query look like?\r\nBring it into R\r\nVisualise Data\r\n\r\nDone? Remember to disconnect!\r\n\r\nStill to comeAcknowledgements\r\n\r\n\r\n\r\n\r\n\r\n.main-container {\r\n    max-width: 600px !important;\r\n}\r\n\r\npre {\r\n  max-height: 800px !important;\r\n  max-width: 600px !important;\r\n  overflow-y: auto !important;\r\n  overflow-x: scroll !important;\r\n}\r\n\r\npre[class] {\r\n  max-height: 100px;\r\n}\r\n\r\n\r\n\r\n\r\nPart I\r\nIn Part I we made a connection to a SQLite DB.\r\nWhat are we tackling in Part II?\r\nWe’ll do more advanced dplyr 📦 workflows.\r\nWe’ll collect the data from the query.\r\ncollecting data is when we bring the data into R. If you recall in the Part I post, all computation was happening on the DB itself, and not pulled into R.\r\nThe project on GitHub, has the example SQLite database, the slides, and some code files.\r\nConnect, and remind ourselves what we’re working with\r\nMake a connection\r\nAs always, our first step is to connect to the database.\r\n\r\n\r\nlibrary(DBI) # main DB interface\r\nlibrary(dplyr) \r\nlibrary(dbplyr) # dplyr back-end for DBs\r\n\r\ncon <- dbConnect(drv = RSQLite::SQLite(), # give me a SQLite connection\r\n        dbname = \"data/great_brit_bakeoff.db\") # To what? The DB named great_brit_bakeoff.db\r\n\r\ndbListTables(con) # List me the tables at the connection\r\n\r\n\r\n [1] \"baker_results\"     \"bakers\"            \"bakes\"            \r\n [4] \"challenge_results\" \"challenges\"        \"episode_results\"  \r\n [7] \"episodes\"          \"ratings\"           \"ratings_seasons\"  \r\n[10] \"results\"           \"seasons\"           \"series\"           \r\n\r\nLet’s get familiar with our data\r\nIn the dataset we have:\r\nresults which tells us how each baker did in the episode - IN, OUT, WINNER etc.\r\nbaker_results which tells us a bit more about the baker’s performance over the entire series - how many times did they win STAR BAKER, how many times they placed in the top 3 etc.\r\nLet’s get an idea of what is in each table.\r\nresults\r\n\r\n\r\ntbl(con, \"results\") %>% # Reach into my connection, and \"talk\" to results table\r\n  head(10) %>%          # get me a subset of the data\r\n  # sometimes if there are many columns, some columns are hidden, \r\n  # this option prints all columns for us\r\n  print(width = Inf)    \r\n\r\n\r\n# Source:   lazy query [?? x 4]\r\n# Database: sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-20-using-the-tidyverse-with-dbs-partii\\data\\great_brit_bakeoff.db]\r\n   series episode baker   result\r\n    <int>   <int> <chr>   <chr> \r\n 1      1       1 Annetha IN    \r\n 2      1       2 Annetha OUT   \r\n 3      1       3 Annetha <NA>  \r\n 4      1       4 Annetha <NA>  \r\n 5      1       5 Annetha <NA>  \r\n 6      1       6 Annetha <NA>  \r\n 7      1       1 David   IN    \r\n 8      1       2 David   IN    \r\n 9      1       3 David   IN    \r\n10      1       4 David   OUT   \r\n\r\n\r\n\r\ntbl(con, \"results\") %>% \r\n  count(result, sort = TRUE) # what categories of \"result\" are there?\r\n\r\n\r\n# Source:     lazy query [?? x 2]\r\n# Database:   sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-20-using-the-tidyverse-with-dbs-partii\\data\\great_brit_bakeoff.db]\r\n# Ordered by: desc(n)\r\n  result         n\r\n  <chr>      <int>\r\n1 IN           452\r\n2 <NA>         376\r\n3 OUT           79\r\n4 STAR BAKER    70\r\n5 RUNNER-UP     18\r\n6 WINNER         9\r\n7 [a]            1\r\n8 WD             1\r\n\r\nbaker_results\r\n\r\n\r\ntbl(con, \"baker_results\") %>% # Reach in and \"talk\" to baker_results\r\n  head() %>%                  # get a glimpse of data\r\n  collect() %>%               # bring that glimpsed data into R \r\n  DT::datatable(options = list(scrollX = TRUE)) # force DT horizontal scrollbar\r\n\r\n\r\n\r\n{\"x\":{\"filter\":\"none\",\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"],[1,1,1,1,1,1],[\"Annetha Mills\",\"David Chambers\",\"Edward \\\"Edd\\\" Kimber\",\"Jasminder Randhawa\",\"Jonathan Shepherd\",\"Lea Harris\"],[\"Annetha\",\"David\",\"Edd\",\"Jasminder\",\"Jonathan\",\"Lea\"],[30,31,24,45,25,51],[\"Single mother\",\"Entrepreneur\",\"Debt collector for Yorkshire Bank\",\"Assistant Credit Control Manager\",\"Research Analyst\",\"Retired\"],[\"Essex\",\"Milton Keynes\",\"Bradford\",\"Birmingham\",\"St Albans\",\"Midlothian, Scotland\"],[\"Mills\",\"Chambers\",\"Kimber\",\"Randhawa\",\"Shepherd\",\"Harris\"],[\"Annetha\",\"David\",\"Edward\",\"Jasminder\",\"Jonathan\",\"Lea\"],[0,0,0,0,0,0],[0,0,2,0,1,0],[1,1,4,2,1,0],[1,3,1,2,2,1],[2,3,1,2,1,10],[7,8,6,5,9,10],[4.5,4.5,2,3,6,10],[0,0,1,0,0,0],[0,0,0,0,0,0],[2,4,6,5,3,1],[14838,14838,14838,14838,14838,14838],[14845,14859,14873,14866,14852,14838],[null,null,null,null,null,null],[null,null,null,null,null,null],[33.3333333333333,66.6666666666667,100,83.3333333333333,50,16.6666666666667],[50,25,66.6666666666667,40,33.3333333333333,0]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>series<\\/th>\\n      <th>baker_full<\\/th>\\n      <th>baker<\\/th>\\n      <th>age<\\/th>\\n      <th>occupation<\\/th>\\n      <th>hometown<\\/th>\\n      <th>baker_last<\\/th>\\n      <th>baker_first<\\/th>\\n      <th>star_baker<\\/th>\\n      <th>technical_winner<\\/th>\\n      <th>technical_top3<\\/th>\\n      <th>technical_bottom<\\/th>\\n      <th>technical_highest<\\/th>\\n      <th>technical_lowest<\\/th>\\n      <th>technical_median<\\/th>\\n      <th>series_winner<\\/th>\\n      <th>series_runner_up<\\/th>\\n      <th>total_episodes_appeared<\\/th>\\n      <th>first_date_appeared<\\/th>\\n      <th>last_date_appeared<\\/th>\\n      <th>first_date_us<\\/th>\\n      <th>last_date_us<\\/th>\\n      <th>percent_episodes_appeared<\\/th>\\n      <th>percent_technical_top3<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"scrollX\":true,\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,4,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}\r\nNotice the use of the collect() function in the code above. I wanted us to be able to get a full glimpse of the data in a nice table, and hence I brought the first few rows of data into R by using the collect() function. This allowed me to then use datatable to display the results a bit better, than the print(width = Inf) alternative.\r\nWhat are we interested in?\r\nLet’s say we want to see how the WINNER and RUNNER-UP(s) did in the series they appeared in.\r\nTo do that we need to get all the baker_results for the WINNER and RUNNER-UP.\r\nJoining data\r\nWhen doing joins we want to find the common columns across the two tables that we can join on.\r\nIn results we have series and baker.\r\nIn baker_results we have series and baker.\r\n❓ 🤔 Why didn’t I also choose the episode column of results as a join column?  ✅ Yes, that column is not in baker_results, since baker_results contains data about how the baker did overall in the series they appeared, that is, one row per baker. The results data however, contains info per baker, per episode, for the series they appeared in - i.e. if they flopped (were OUT 😉), in the second episode of a series that contained 10 episodes, their name would appear 10 times in the results table, but their “result” value will be NA from episode 3 onwards.\r\nRemember the tbl(con, \"tbl_name\") always\r\nI’d like to bring to your attention the use of tbl(con, \"table_1\") and tbl(con, \"table_2\") in the join function.\r\nWe must always keep this in mind, because baker_results and results don’t exist in R yet. We’re talking to those tables in our relational database management system (RDBMS), so we always have to do so through our connection.\r\n\r\n\r\nset.seed(42)\r\ntbl(con, \"baker_results\") %>% # use connection to \"talk\" to baker_results\r\n  inner_join(tbl(con, \"results\"), # use connection to \"talk\" to results and join both tables \r\n        by = c('baker' = 'baker',\r\n               'series' = 'series')) %>% # join criteria \r\n  collect() %>% # get it into R\r\n  sample_n(size = 3) %>% # take a random sample\r\n  print(width = Inf) # print all columns\r\n\r\n\r\n# A tibble: 3 x 26\r\n  series baker_full     baker     age occupation                 \r\n   <dbl> <chr>          <chr>   <dbl> <chr>                      \r\n1      6 Ian Cumming    Ian        41 Travel photographer        \r\n2      4 Frances Quinn  Frances    31 Children's Clothes Designer\r\n3      2 Yasmin Limbert Yasmin     43 Childminder                \r\n  hometown                          baker_last baker_first star_baker\r\n  <chr>                             <chr>      <chr>            <int>\r\n1 Great Wilbraham, Cambridgeshire   Cumming    Ian                  3\r\n2 Market Harborough, Leicestershire Quinn      Frances              1\r\n3 West Kirby, The Wirral            Limbert    Yasmin               1\r\n  technical_winner technical_top3 technical_bottom technical_highest\r\n             <int>          <int>            <int>             <dbl>\r\n1                1              6                4                 1\r\n2                1              7                3                 1\r\n3                0              2                4                 2\r\n  technical_lowest technical_median series_winner series_runner_up\r\n             <dbl>            <dbl>         <int>            <int>\r\n1                8                3             0                1\r\n2                8                3             1                0\r\n3                6                5             0                0\r\n  total_episodes_appeared first_date_appeared last_date_appeared\r\n                    <dbl>               <dbl>              <dbl>\r\n1                      10               16652              16715\r\n2                      10               15937              16000\r\n3                       6               15202              15237\r\n  first_date_us last_date_us percent_episodes_appeared\r\n          <dbl>        <dbl>                     <dbl>\r\n1         16983        17025                       100\r\n2         16432        16495                       100\r\n3            NA           NA                        75\r\n  percent_technical_top3 episode result\r\n                   <dbl>   <int> <chr> \r\n1                   60         5 IN    \r\n2                   70         5 IN    \r\n3                   33.3       5 IN    \r\n\r\nNotice that all columns of baker_results appear first and then we have the “extra” columns from results i.e. episode and result.\r\nCommon mistake\r\nI included the above to show that each time we “talk” to a table we must do so through our connection, because I often make the mistake of not including the tbl(con, \"name_of_tbl_i_am_joining\") in the join function. I, more times than I care to admit 🤦, incorrectly write:\r\n\r\n  tbl(con, \"table1\") %>% # correct -> \"talk\" through connection\r\n     left_join(table2,   # incorrect -> forgot to use the connection\r\n          by = c(\"tbl1_name1\" = \"tbl2_name1\"))\r\n\r\nI would like to help you, not repeat my mistake 😕, so heads up AVOID THE FOLLOWING 🚏:\r\n\r\n\r\ntbl(con, \"baker_results\") %>% # use connection to \"talk\" to baker_results\r\n  inner_join(results,  # OOPS! I forgot the tbl(con, \"results\")\r\n        by = c('baker' = 'baker',\r\n               'series' = 'series'))  \r\n\r\n\r\nError in tbl_vars_dispatch(x): object 'results' not found\r\n\r\nCollect\r\nOk, let us now do our entire pipeline, and only bring the data into R when we’ve got what we’re looking for.\r\nWe need to:\r\nJoin the tables\r\nFilter the data for WINNER and RUNNER-UP in the result column.\r\nSelect only the columns we’re interested in.\r\n\r\n\r\n(final_query <- tbl(con, \"baker_results\") %>% # use connection to \"talk\" to baker_results\r\n  inner_join(tbl(con, \"results\"), # use connection to \"talk\" to results and join both tables \r\n        by = c('baker' = 'baker',\r\n               'series' = 'series')) %>% # join criteria \r\n  filter(result %in% c(\"WINNER\", \"RUNNER-UP\")) %>% # filter rows we're interested in\r\n  select(series, baker:percent_technical_top3,\r\n         result))\r\n\r\n\r\n# Source:   lazy query [?? x 24]\r\n# Database: sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-20-using-the-tidyverse-with-dbs-partii\\data\\great_brit_bakeoff.db]\r\n   series baker   age occupation hometown baker_last baker_first\r\n    <dbl> <chr> <dbl> <chr>      <chr>    <chr>      <chr>      \r\n 1      1 Edd      24 Debt coll~ Bradford Kimber     Edward     \r\n 2      1 Mira~    37 Food buye~ Midhurs~ Browne     Miranda    \r\n 3      1 Ruth     31 Retail ma~ Poynton~ Clemens    Ruth       \r\n 4      2 Holly    31 Advertisi~ Leicest~ Bell       Holly      \r\n 5      2 Joan~    41 Housewife  Ongar, ~ Wheatley   Joanne     \r\n 6      2 Mary~    45 Housewife  Kidderm~ Boermans   Mary-Anne  \r\n 7      3 Bren~    63 Recruitme~ Sutton ~ Lynch      Brendan    \r\n 8      3 James    21 Medical s~ Hillswi~ Morton     James      \r\n 9      3 John     23 Law stude~ Wigan    Whaite     John       \r\n10      4 Fran~    31 Children'~ Market ~ Quinn      Frances    \r\n# ... with more rows, and 17 more variables: star_baker <int>,\r\n#   technical_winner <int>, technical_top3 <int>,\r\n#   technical_bottom <int>, technical_highest <dbl>,\r\n#   technical_lowest <dbl>, technical_median <dbl>,\r\n#   series_winner <int>, series_runner_up <int>,\r\n#   total_episodes_appeared <dbl>, first_date_appeared <dbl>,\r\n#   last_date_appeared <dbl>, first_date_us <dbl>,\r\n#   last_date_us <dbl>, percent_episodes_appeared <dbl>,\r\n#   percent_technical_top3 <dbl>, result <chr>\r\n\r\nThe above code just sets up the query that will be executed should we run (Ctrl + Enter) final_query in R (hence the lazy query [?? x 24] in the output). No data is collected (i.e. present in your local R environment) as yet.\r\nWhat does the query look like?\r\n\r\n\r\n.scroll-100 {\r\n  white-space:pre !important;\r\n  max-width: 100px;\r\n  overflow-x: scroll;\r\n  background-color: inherit;\r\n}\r\ncode.r{\r\n  font-size: 10px;\r\n}\r\n\r\n\r\n\r\n\r\nfinal_query %>% \r\n  show_query() \r\n\r\n\r\n<SQL>\r\nSELECT `series`, `baker`, `age`, `occupation`, `hometown`, `baker_last`, `baker_first`, `star_baker`, `technical_winner`, `technical_top3`, `technical_bottom`, `technical_highest`, `technical_lowest`, `technical_median`, `series_winner`, `series_runner_up`, `total_episodes_appeared`, `first_date_appeared`, `last_date_appeared`, `first_date_us`, `last_date_us`, `percent_episodes_appeared`, `percent_technical_top3`, `result`\r\nFROM (SELECT `LHS`.`series` AS `series`, `baker_full`, `LHS`.`baker` AS `baker`, `age`, `occupation`, `hometown`, `baker_last`, `baker_first`, `star_baker`, `technical_winner`, `technical_top3`, `technical_bottom`, `technical_highest`, `technical_lowest`, `technical_median`, `series_winner`, `series_runner_up`, `total_episodes_appeared`, `first_date_appeared`, `last_date_appeared`, `first_date_us`, `last_date_us`, `percent_episodes_appeared`, `percent_technical_top3`, `episode`, `result`\r\nFROM `baker_results` AS `LHS`\r\nINNER JOIN `results` AS `RHS`\r\nON (`LHS`.`baker` = `RHS`.`baker` AND `LHS`.`series` = `RHS`.`series`)\r\n)\r\nWHERE (`result` IN ('WINNER', 'RUNNER-UP'))\r\n\r\n\r\n\r\nBring it into R\r\nNow finally, we are ready to bring our filtered and joined data into R by using collect().\r\n\r\n\r\n(top_performers <- final_query %>% \r\n  collect())\r\n\r\n\r\n# A tibble: 24 x 24\r\n   series baker   age occupation hometown baker_last baker_first\r\n    <dbl> <chr> <dbl> <chr>      <chr>    <chr>      <chr>      \r\n 1      1 Edd      24 Debt coll~ Bradford Kimber     Edward     \r\n 2      1 Mira~    37 Food buye~ Midhurs~ Browne     Miranda    \r\n 3      1 Ruth     31 Retail ma~ Poynton~ Clemens    Ruth       \r\n 4      2 Holly    31 Advertisi~ Leicest~ Bell       Holly      \r\n 5      2 Joan~    41 Housewife  Ongar, ~ Wheatley   Joanne     \r\n 6      2 Mary~    45 Housewife  Kidderm~ Boermans   Mary-Anne  \r\n 7      3 Bren~    63 Recruitme~ Sutton ~ Lynch      Brendan    \r\n 8      3 James    21 Medical s~ Hillswi~ Morton     James      \r\n 9      3 John     23 Law stude~ Wigan    Whaite     John       \r\n10      4 Fran~    31 Children'~ Market ~ Quinn      Frances    \r\n# ... with 14 more rows, and 17 more variables: star_baker <int>,\r\n#   technical_winner <int>, technical_top3 <int>,\r\n#   technical_bottom <int>, technical_highest <dbl>,\r\n#   technical_lowest <dbl>, technical_median <dbl>,\r\n#   series_winner <int>, series_runner_up <int>,\r\n#   total_episodes_appeared <dbl>, first_date_appeared <dbl>,\r\n#   last_date_appeared <dbl>, first_date_us <dbl>,\r\n#   last_date_us <dbl>, percent_episodes_appeared <dbl>,\r\n#   percent_technical_top3 <dbl>, result <chr>\r\n\r\nHow about that? Notice the A tibble: 24 x 24! R now, has the data in it’s local environment, and can definitively tell us it knows there are 24 observations (no more lazy query) 😄.\r\nVisualise Data\r\nNow that we have finalised what data we wanted from our RDBMS, executed our query, and collected the data into our R environment we can do further processing, create plots for reports etc.\r\nI am interested in understanding how did the winner and runner-up(s) of series 6 do across the season in terms of technical challenges etc.?\r\n\r\n\r\nlibrary(tidyverse)\r\n\r\ntop_performers %>% \r\n  # filter for season we're interested in\r\n  filter(series == 6) %>%\r\n  # format baker nicely so we see winner, then runner-up(s)\r\n  mutate(baker_name = factor(str_glue(\"{result} - {baker}\")),\r\n         baker_name = fct_rev(baker_name)) %>% \r\n  # let's convert all the tech info cols to be a metric name, \r\n  # and put the value in the value column \r\n  # (by default values_to = \"value\" in pivot_longer())\r\n  pivot_longer(cols = c(star_baker:technical_median),\r\n               names_to = \"metric\") %>% \r\n  mutate(metric = fct_reorder(metric, value)) %>% \r\n  ggplot(aes(x = value, y = metric)) +\r\n  geom_col(fill = \"#727d97\") +\r\n  facet_wrap(~ baker_name) +\r\n  labs(title = str_glue(\"Metrics for Season \",\r\n    \"{top_performers %>%  filter(series == 6) %>%\r\n    select(series) %>% distinct()}'s Winner and Runner-Up(s)\"),\r\n    y = \"\") +\r\n  theme_light() +\r\n  theme(panel.spacing = unit(1, \"lines\")) +\r\n  theme(strip.background =element_rect(fill=\"#f4e4e7\"))+\r\n  theme(strip.text = element_text(colour = \"#5196b4\"))\r\n\r\n\r\n\r\n\r\nGiven that Nadiya was a technical winner more times than the other contestants, and that her technical_lowest was better (higher number is better) it looks like she had a good run throughout the series, and was a deserved winner.\r\nDone? Remember to disconnect!\r\nGood housekeeping means always remembering to disconnect once you’re done.\r\n\r\n\r\ndbDisconnect(con) # closes our DB connection\r\n\r\n\r\n\r\nStill to come\r\nSetting up an external DB in PostgreSQL / MySQL.\r\nConnecting to said DB, and running SQL workloads on it.\r\nAcknowledgements\r\nThe Great British Bake Off data from Dr. Alison Hill.\r\nEdgar Ruiz’s database work, and teachings.\r\n\r\n\r\n\r\n",
    "preview": "posts/2020-12-20-using-the-tidyverse-with-dbs-partii/Paper.R_Programming.4.png",
    "last_modified": "2020-12-21T03:11:50+02:00",
    "input_file": {},
    "preview_width": 2048,
    "preview_height": 1536
  },
  {
    "path": "posts/2020-12-12-using-the-tidyverse-with-databases/",
    "title": "Using the tidyverse with Databases - Part I",
    "description": "You don't need to be a SQL expert to work with Databases through R",
    "author": [
      {
        "name": "Vebash Naidoo",
        "url": "https://twitter.com/Sciencificity"
      }
    ],
    "date": "2020-12-12",
    "categories": [
      "SQL",
      "databases",
      "tidyverse",
      "dbplyr"
    ],
    "contents": "\r\n\r\nContents\r\nBackground\r\nIntro to using Databases in R, with Tidyverse tools (Part I)Motivation\r\nConnecting to a DatabasePackages needed\r\nThe database we’ll use\r\nConnecting to a SQLite DB\r\n\r\nTake a look aroundDBI Functions\r\ndplyr Functions\r\nHave a look at the SQL behind the scenes\r\nWhat’s with this lazy query / ?? we’re seeing?\r\n\r\nDone? Remember to disconnect!\r\n\r\nSlides\r\nStill to comeAcknowledgements\r\n\r\n\r\n\r\nBackground\r\nOn the 1st of December I certified as an RStudio Tidyverse Instructor. As part of the process I prepared a sample lesson that was delivered during the exam. In a series of posts I will go through an extension of that sample lesson.\r\nIntro to using Databases in R, with Tidyverse tools (Part I)\r\nMotivation\r\nYou often have data in a corporate or institutional database (often termed relational database management system, or RDBMS). The language to talk with such a database (DB) is some variant of the language SQL (Structured Query Language). I say some variant, since a vendor providing an RDBMS may adopt the standardised SQL, but they may also extend it with their own variations.\r\nIf you use different RDBMS’s from different vendors you need to understand how to query that DB using the particular SQL dialect used by that vendor. For example, we use PostgreSQL, and we also use PrestoDB (for Athena on AWS). JSON fields in the PostgreSQL DB are ingested as structured nested arrays in AWS and hence when querying the same field we use different query syntax.\r\nYou know R, especially the dplyr 📦. Even though the dplyr 📦 is so well written to mimic the SQL syntax - select(), group_by(), left_join() etc. there is still a cognitive load when you switch between using R syntax, and SQL syntax (ask me, who has often written == in SQL syntax on Athena only to wonder why I am getting an error 🤐).\r\nYou only have so much memory in your local environment, and may want your RDBMS to do the heavy lifting (most of the computation), and only pull data into R when you need to (e.g. pull in aggregated data to create plots for a report).\r\nIn this tutorial you will learn how to use dbplyr, which is a database back-end of dplyr, to execute queries directly in your RDBMS all the while writing R tidyverse syntax 😮 ⭐.\r\nConnecting to a Database\r\nPackages needed\r\nDBI: This is the main package which is a Database Interface for R.install.packages(\"DBI\")\r\ndbplyr: The 📦 we may use to talk to our database, all the while using dplyr syntax in our code.install.packages(\"dbplyr\")\r\ndplyr: To select(), group_by() as well as “talk”, via the connection we will establish, to a database table.\r\nRSQLite: DBI compliant package that allows a connection to a lightweight single user SQLite DB.install.packages(\"RSQLite\")\r\nOther DBI compliant R packages you may need for your use case - e.g. RPostgres is for connecting to a PostgreSQL RDBMS. Note: Not used in this tutorial (brief overview in slides), and RStudio’s DB Website is a treasure trove of information 👩‍💻.\r\nodbc: This is a DBI compliant interface to allow you to interface to your RDBMS using an odbc driver.Note: Not used in this tutorial (brief overview in slides), and again RStudio’s DB Website has useful information in this regard too!install.packages(\"odbc\")\r\nThe database we’ll use\r\nAlison Hill created a dataset for The Great British Bake Off. I used the data from her package to create a SQLite DB that we will use to practise on.\r\nConnecting to a SQLite DB\r\nFor the purposes of this tutorial we will connect to a SQLite DB that I created. To talk to the DB we need to first make a connection.\r\nLoad the DBI package: library(DBI)\r\nMake a connection: con <- dbConnect(RSQLite::SQLite(), \"mydb.db\")\r\n\r\n\r\nlibrary(DBI) # main DB interface\r\nlibrary(dplyr) \r\nlibrary(dbplyr) # dplyr back-end for DBs\r\n\r\ncon <- dbConnect(drv = RSQLite::SQLite(), # give me a SQLite connection\r\n        dbname = \"data/great_brit_bakeoff.db\") # To what? The DB named great_brit_bakeoff.db\r\nsummary(con) # What do we have? \r\n\r\n\r\n          Length            Class             Mode \r\n               1 SQLiteConnection               S4 \r\n\r\nOk, we have successfully managed to connect to the DB.\r\nTake a look around\r\nAlright, we’ve made a connection now what? Let’s have a look around using some DBI functions.\r\nDBI Functions\r\n\r\n\r\ndbListTables(con) # List me the tables at the connection\r\n\r\n\r\n [1] \"baker_results\"     \"bakers\"            \"bakes\"            \r\n [4] \"challenge_results\" \"challenges\"        \"episode_results\"  \r\n [7] \"episodes\"          \"ratings\"           \"ratings_seasons\"  \r\n[10] \"results\"           \"seasons\"           \"series\"           \r\n\r\ndbListFields(con, # Reach into my connection and ...\r\n      \"bakers\")   # tell me what fields does the `bakers` table have?\r\n\r\n\r\n[1] \"series\"     \"baker_full\" \"age\"        \"occupation\" \"hometown\"  \r\n\r\nres <- dbSendQuery(con, \"SELECT * FROM bakers LIMIT 3\") # Execute a query\r\ndbFetch(res) # get the result\r\n\r\n\r\n  series          baker_full age                        occupation\r\n1      1       Annetha Mills  30                           Midwife\r\n2      1      David Chambers  31                      Entrepreneur\r\n3      1 Edward \"Edd\" Kimber  24 Debt collector for Yorkshire Bank\r\n       hometown\r\n1         Essex\r\n2 Milton Keynes\r\n3      Bradford\r\n\r\ndbClearResult(res) # clear the result\r\n\r\n\r\n\r\ndplyr Functions\r\nOk, let’s flex our dplyr skills 😄.\r\ntbl(con, \"name_of_table\") says using my connection “con” go execute a SELECT * FROM name_of_table.\r\n\r\n\r\ntbl(con, \"bakers\") # let's have a look - works like glimpse()\r\n\r\n\r\n# Source:   table<bakers> [?? x 5]\r\n# Database: sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-12-using-the-tidyverse-with-databases\\data\\great_brit_bakeoff.db]\r\n   series baker_full          age occupation            hometown      \r\n    <dbl> <chr>             <dbl> <chr>                 <chr>         \r\n 1      1 \"Annetha Mills\"      30 Midwife               Essex         \r\n 2      1 \"David Chambers\"     31 Entrepreneur          Milton Keynes \r\n 3      1 \"Edward \\\"Edd\\\" ~    24 Debt collector for Y~ Bradford      \r\n 4      1 \"Jasminder Randh~    45 Assistant Credit Con~ Birmingham    \r\n 5      1 \"Jonathan Shephe~    25 Research Analyst      St Albans     \r\n 6      1 \"Lea Harris\"         51 Retired               Midlothian, S~\r\n 7      1 \"Louise Brimelow\"    44 Police Officer        Manchester    \r\n 8      1 \"Mark Whithers\"      48 Bus Driver            South Wales   \r\n 9      1 \"Miranda Gore Br~    37 Food buyer for Marks~ Midhurst, Wes~\r\n10      1 \"Ruth Clemens\"       31 Retail manager/House~ Poynton, Ches~\r\n# ... with more rows\r\n\r\ntbl(con, \"bakers\") %>% \r\n  head(3) # \"SELECT * FROM bakers LIMIT 3\"\r\n\r\n\r\n# Source:   lazy query [?? x 5]\r\n# Database: sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-12-using-the-tidyverse-with-databases\\data\\great_brit_bakeoff.db]\r\n  series baker_full           age occupation               hometown   \r\n   <dbl> <chr>              <dbl> <chr>                    <chr>      \r\n1      1 \"Annetha Mills\"       30 Midwife                  Essex      \r\n2      1 \"David Chambers\"      31 Entrepreneur             Milton Key~\r\n3      1 \"Edward \\\"Edd\\\" K~    24 Debt collector for York~ Bradford   \r\n\r\nNotice that each time we used con. We use our connection con to “talk” to our database, and we will use it throughout, even in our tidy pipelines.\r\nIn baker_results we have the baker with their details, as well as their standing in the series competition. Let’s say we wanted to know if the winners came from different areas in Britain, or from some areas in particular.\r\n\r\n\r\ndbListFields(con, \"baker_results\")\r\n\r\n\r\n [1] \"series\"                    \"baker_full\"               \r\n [3] \"baker\"                     \"age\"                      \r\n [5] \"occupation\"                \"hometown\"                 \r\n [7] \"baker_last\"                \"baker_first\"              \r\n [9] \"star_baker\"                \"technical_winner\"         \r\n[11] \"technical_top3\"            \"technical_bottom\"         \r\n[13] \"technical_highest\"         \"technical_lowest\"         \r\n[15] \"technical_median\"          \"series_winner\"            \r\n[17] \"series_runner_up\"          \"total_episodes_appeared\"  \r\n[19] \"first_date_appeared\"       \"last_date_appeared\"       \r\n[21] \"first_date_us\"             \"last_date_us\"             \r\n[23] \"percent_episodes_appeared\" \"percent_technical_top3\"   \r\n\r\ntbl(con, \"baker_results\") %>% \r\n  select(series, baker, hometown, series_winner) # normal dplyr select\r\n\r\n\r\n# Source:   lazy query [?? x 4]\r\n# Database: sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-12-using-the-tidyverse-with-databases\\data\\great_brit_bakeoff.db]\r\n   series baker     hometown              series_winner\r\n    <dbl> <chr>     <chr>                         <int>\r\n 1      1 Annetha   Essex                             0\r\n 2      1 David     Milton Keynes                     0\r\n 3      1 Edd       Bradford                          1\r\n 4      1 Jasminder Birmingham                        0\r\n 5      1 Jonathan  St Albans                         0\r\n 6      1 Lea       Midlothian, Scotland              0\r\n 7      1 Louise    Manchester                        0\r\n 8      1 Mark      South Wales                       0\r\n 9      1 Miranda   Midhurst, West Sussex             0\r\n10      1 Ruth      Poynton, Cheshire                 0\r\n# ... with more rows\r\n\r\nNotice how our dplyr select() has trimmed down the number of columns from 24 to 4.\r\nTime to see if our winning bakers hail from similar hometowns or not.\r\n\r\n\r\ntbl(con, \"baker_results\") %>% \r\n  select(series, baker, hometown, series_winner) %>% \r\n  filter(series_winner == 1) %>% # normal dplyr filter\r\n  count(hometown, sort = TRUE)   # normal dplyr count\r\n\r\n\r\n# Source:     lazy query [?? x 2]\r\n# Database:   sqlite 3.33.0\r\n#   [C:\\Personal\\Blog_Vebash\\_posts\\2020-12-12-using-the-tidyverse-with-databases\\data\\great_brit_bakeoff.db]\r\n# Ordered by: desc(n)\r\n  hometown                              n\r\n  <chr>                             <int>\r\n1 Wigan                                 1\r\n2 West Molesey, Surrey                  1\r\n3 Ongar, Essex                          1\r\n4 Market Harborough, Leicestershire     1\r\n5 Leeds / Luton                         1\r\n6 Bradford                              1\r\n7 Barton-Upon-Humber, Lincolnshire      1\r\n8 Barton-Le-Clay, Bedfordshire          1\r\n\r\nLooks like our winners are from very different areas.\r\nHave a look at the SQL behind the scenes\r\nOur dplyr syntax is converted behind the scenes to SQL which is executed directly on the DB table.\r\n\r\n\r\ntbl(con, \"baker_results\") %>% \r\n  select(series, baker, hometown, series_winner) %>% \r\n  filter(series_winner == 1) %>% \r\n  count(hometown, sort = TRUE) %>% \r\n  show_query()\r\n\r\n\r\n<SQL>\r\nSELECT `hometown`, COUNT(*) AS `n`\r\nFROM (SELECT `series`, `baker`, `hometown`, `series_winner`\r\nFROM `baker_results`)\r\nWHERE (`series_winner` = 1.0)\r\nGROUP BY `hometown`\r\nORDER BY `n` DESC\r\n\r\nThat’s pretty nifty, and helps you learn SQL in the process - it is always good to know, and read SQL, which is used extensively in work and institutional environments.\r\nWhat’s with this lazy query / ?? we’re seeing?\r\nYou might have noticed that our pipelines have a:\r\nSource: table [?? x 5] OR\r\nSource: lazy query [?? x 4]\r\nin the output results.\r\nWhy is this?\r\nBehind the scenes the dplyr code we write, gets converted to SQL (the particular dialect of the DB we’re connecting to).\r\nThe SQL is executed directly on the DB. I.e. the data is not first brought into R and manipulated in R. Instead we send the query to the DB, and the DB does the computation.\r\nWhen we use a dplyr pipeline to execute a query on the DB, the DB does the computation and sends us back a glimpse of the executed end result.\r\nIt is for this reason, we see the ?? - we’re being told “Hey, I executed this query (your pipeline converted to SQL) on the DB at connection con, and here’s a snippet of the output, but I did not get the meta-info on how many rows were produced, I just know that I got x_number of columns in the output.”\r\nWe will see in the next part of the tutorial how to get the info into R, and understand how many rows were produced etc.\r\nDone? Remember to disconnect!\r\nGood housekeeping means always remembering to disconnect once you’re done.\r\n\r\n\r\ndbDisconnect(con) # closes our DB connection\r\n\r\n\r\n\r\nTo see that is indeed the case let’s see if we can use the connection further …\r\n\r\n\r\ndbListTables(con)\r\n\r\n\r\nError: Invalid or closed connection\r\n\r\nSlides\r\nIf you’d like to dive in please check out the slides, and the project on GitHub.\r\n\r\n\r\n\r\n\r\n\r\n\r\nfitvids('.shareagain', {players: 'iframe'});\r\n\r\nStill to come\r\nMore dplyr, for example joining tables.\r\nGetting the data into R.\r\nAcknowledgements\r\nSlide inspiration, as well as some of the background pictures are from Dr. Alison Hill.\r\nThe Great British Bake Off data from Dr. Alison Hill.\r\nEdgar Ruiz’s database work, and teachings.\r\n\r\n\r\n\r\n",
    "preview": "posts/2020-12-12-using-the-tidyverse-with-databases/data2-unsplash.jpg",
    "last_modified": "2020-12-15T00:46:20+02:00",
    "input_file": {}
  }
]
